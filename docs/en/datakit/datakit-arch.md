# Introduction to the Overall Architecture of DataKit
---

DataKit is a fundamental data collection tool that runs on users' local machines. It primarily collects various metrics and log data from system operations, aggregates them, and sends them to [Guance](https://guance.com){:target="_blank"}. Within Guance, users can view and analyze their various metrics, logs, and other data.

DataKit is a critical data collection component in Guance, as almost all data in Guance originates from DataKit.

## DataKit Basic Network Model {#network-arch}

The DataKit network model mainly consists of three layers, which can be simply summarized as the user environment, DataWay, and the Guance center, as shown in the figure below:

<figure markdown>
  ![](https://static.guance.com/images/datakit/dk-network-arch.png){ width="800" }
  <figcaption> DataKit Basic Network Model </figcaption>
</figure>

<!-- markdownlint-disable MD029 -->

1. DataKit primarily collects various different metrics at regular intervals and sends the data to DataWay via HTTP(s) periodically and quantitatively. Each DataKit is configured with a corresponding token to identify different users.

> Note: If the user's internal network environment does not have external network requests enabled, you can use [Nginx as a proxy layer](../integrations/proxy.md#nginx-proxy), or you can achieve traffic proxying through the built-in [Proxy collector](../integrations/proxy.md) in DataKit.

2. After receiving the data, DataWay forwards it to Guance, including an API signature in the data sent to Guance.
3. Upon receiving valid data, Guance writes the data into different storages based on the data type.

For data collection business, partial data loss is generally allowed (since the data itself is collected intermittently, data within the intermittent period can be considered lost). Currently, the entire data transmission chain has implemented the following loss protection:

1. If DataKit fails to send data to DataWay due to certain network reasons, DataKit will cache up to one thousand data points. When the cached data exceeds this amount, the cache will be cleared.
2. If DataWay fails to send data to Guance for some reason or cannot send data to Guance in time due to high traffic, DataWay will persist these data to disk. Once traffic decreases or the network recovers, DataWay will send the data to Guance. Delayed data does not affect timeliness, as timestamps are attached to the cached data.

On DataWay, to protect the disk, the maximum disk usage can also be configured to prevent the storage of the node from being overwhelmed. For data exceeding the usage limit, DataWay chooses to discard the data. However, this capacity is usually set to be relatively large.

## DataKit Internal Architecture {#internal-arch}

The internal architecture of DataKit is relatively simple, as shown in the figure below:

<figure markdown>
  ![](https://static.guance.com/images/datakit/dk-internal-arch.png){ width="800" }
  <figcaption> DataKit Internal Collection Architecture </figcaption>
</figure>

From top to bottom, the main components of the DataKit internal structure are divided into three layers:

- Top Layer: Includes the program entry module and some common modules
    - Configuration Loading Module: In addition to its main configuration (`conf.d/datakit.conf`), each collector's configuration is separately configured. If they were all combined, the configuration file could become very large and difficult to edit.
    - Service Management Module: Responsible for managing the entire DataKit service.
    - Toolchain Module: As a client program, DataKit provides many additional functions besides data collection, such as viewing documentation, restarting services, updating, etc., all implemented in the toolchain module.
    - Pipeline Module: In log processing, [Pipeline scripts](../pipeline/use-pipeline/index.md) are used to parse logs, converting unstructured log data into structured data. Similar data processing can also be performed on non-log data.
    - Election Module: When deploying a large number of DataKits, users can make all DataKit configurations identical and deploy them using [automated batch deployment](datakit-batch-deploy.md). The election module ensures that, in a cluster, only one DataKit should collect certain data (to avoid duplicate data and reduce pressure on the target). In a cluster where all DataKit configurations are identical, the election module ensures that at any given time, at most one DataKit performs the collection.
    - Documentation Module: DataKit's documentation is generated by its own code, facilitating automatic documentation release.

- Transport Layer: Responsible for almost all data input and output

    - HTTP Service Module: DataKit supports third-party data integration, such as [Telegraf](../integrations/telegraf.md)/[Prometheus](../integrations/prom.md). Currently, this data is integrated via HTTP.
    - IO Module: After each data collection, the plugins send the data to the IO module. The IO module encapsulates unified interfaces for data construction, processing, and sending, making it easy to integrate data from various collectors. Additionally, the IO module sends data to DataWay via HTTP(s) at regular intervals and in fixed quantities.

- Collection Layer: Responsible for collecting various types of data. Based on the collection method, it is divided into two categories:

    - Active Collection Type: These collectors collect data at fixed frequencies as configured, such as [CPU](../integrations/cpu.md), [network card traffic](../integrations/net.md), [cloud dial testing](../integrations/dialtesting.md), etc.
    - Passive Collection Type: These collectors typically implement collection through external data input, such as [RUM](../integrations/rum.md), [Tracing](../integrations/ddtrace.md), etc. They usually run outside of DataKit and can upload data to Guance via DataKit's [data upload API](apis.md) after standardization.

Each different collector runs independently in its own goroutine, with outer-layer protection. Even if a single collector crashes (each collector is allowed to crash up to 6 times during runtime), it will not affect the overall operation of DataKit.

To prevent collectors from causing unexpected performance overhead on the user's environment, such as setting the collection frequency too high (accidentally setting `1m` to `1ms`), DataKit has a global protection mode (which can be globally disabled, similar to a system firewall) that automatically adjusts erroneous settings to more reasonable ones.

Over 98% of DataKit's code is developed in Golang, currently supporting mainstream platforms like [Linux/Mac/Windows](datakit-service-how-to.md#install-dir). Since DataKit runs as a service in the user's environment, it should not have too many dependencies on the running environment and should not cause significant performance consumption. Currently, the basic operational performance of DataKit is as follows:

- Minimal environmental dependencies: Most collectors are integrated with the main DataKit program (all developed in Golang), with very few dynamic library or environmental dependencies (such as Python environment dependencies). Users can meet these requirements with simple operations.
- Resource control: Resident memory consumption is approximately 30MB, CPU consumption is controlled around 3% (tested on Intel(R) Core(TM) i5-5200U CPU @ 2.20GHz, with room for optimization); disk consumption is negligible. Network traffic depends on the specific amount of data collected. All DataKit traffic is sent in compressed [line protocol](apis.md) format, maintaining readability while keeping data volume small.

In theory, any observable data can be collected through DataKit. As user demand for observable data grows, DataKit will gradually increase support for more types of data collection. Thanks to the high extensibility of DataKit's plugin model, achieving this goal becomes exceptionally simple.
