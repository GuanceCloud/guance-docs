# Platypus 语法
---

以下是 Pipeline 处理器使用的 Platypus 语言的语法定义。随着不同语法的逐步支持，该文档会做不同程度的调整和增删。

## 标识符与关键字 {#identifier-and-keyword}

### 标识符 {#identifier}

标识符用于标识对象，可以用来表示一个变量、函数等，标识符包含关键字；自定义的标识符不能与 Pipeline 数据处理器语言的关键字重复；

标识符可以由数字(`0-9`)、字母(`A-Z a-z`)、下划线(`_`) 构成，但首字符不能是数字且区分大小写：

- `_abc`
- `abc`
- `abc1`
- `abc_1_`

如果需要以非字母或非下划线开头，或在标识符中使用非上述字符时需要使用反引号：

- `` `1abc` ``
- `` `@some-variable` ``
- `` ` 这是一个表情包变量👍` ``

**特殊约定**：

我们约定以标识符 `_` 代表 Pipeline 数据处理器的输入数据，这一参数可能隐式传递给部分内置函数；

在当前版本使用时，为保持前向兼容，`_` 将被视为 `message` 的别名。

### 关键字 {#keyword}

关键字是具有特殊意义的单词，如 `if`, `elif`, `else`, `for`, `in`, `break`, `continue`, `nil` 等，这些单词不能作为变量、常量或函数等的名字。

## 注释 {#comments}

以 `#` 为行注释字符，不支持行内注释

```python
# 这是一行注释
a = 1 # 这是一行注释

"""
这是一个（多行）字符串，替代注释
"""
a = 2

"字符串"
a = 3
```

## 内置数据类型 {#built-in-data-types}

在 Pipeline 数据处理器语言 Platypus 中，默认情况下，变量的值的类型可以动态变化，但每一个值都有其数据类型，其可以是**基本类型**的其中一种，也可以是**复合类型**

当一个变量未赋值时，其值为 nil，表示无值。

### 基本类型 {#basic-type}

#### 整数(int)类型 {#int-type}

整型的类型长度为 64bit，有符号，当前仅支持以十进制的方式编写整数字面量，如 `-1`, `0`, `1`, `+19`

#### 浮点(float)类型 {#float-type}

浮点型的类型长度为 64bit，有符号，当前仅支持以十进制的方式编写浮点数字面量，如 `-1.00001`, `0.0`, `1.0`, `+19.0`

#### 布尔(bool)类型 {#bool-type}

布尔类型字面量仅有 `true` 和 `false` 两种

#### 字符串(str)类型 {#str-type}

字符串字面量可用双引号或单引号，多行字符串可以使用三双引号或三单引号将内容括起来进行编写

- `"hello world"`
- `'hello world'`
- 使用 `"""` 表达多行字符串

  ```python
  """hello
  world"""
  ```

- 使用 `'''` 表达多行字符串
  
  ```python
  '''
  hello
  world
  '''
  ```

### 复合类型 {#composite-type}

map 类型与 list 类型与其他类型不同，多个变量可以指向同一个 map 或 list 对象，在赋值时并不会进行 list 或 map 的内存拷贝，而是对该 map/list 值的内存地址进行引用。

#### Map 类型 {#map-type}

map 类型为 key-value 结构，（当前）只有字符串类型才能作为 key，不限制 value 的数据类型。

其可通过索引表达式读写 map 中的元素：

```python
a = {
  "1": [1, "2", 3, nil],
  "2": 1.1,
  "abc": nil,
  "def": true
}

# 由于 a["1"] 是 list 对象，此时 b 只是引用了 a["1"] 的值
b = a["1"]

"""
此时 a["1"][0] == 1.1
"""
b[0] = 1.1
```

#### List 类型 {#list-type}

list 类型可以在 list 中存储任意数量、任意类型的值。

其可通过索引表达式读写 list 中的元素：

```python
a = [1, "2", 3.0, false, nil, {"a": 1}]

a = a[0] # a == 1
```

## 运算符 {#operator}

以下为 Platypus 当前支持的运算符，数值越大优先级越高：

|优先级|符号|结合性|描述|
|-|-|-|-|
| 1 | `=`  | 右 | 赋值；命名参数；优先级最低|
| 1 | `+=` | 右 | 赋值，左操作数 = 左操作数 + 右操作数|
| 1 | `-=` | 右 | 赋值，左操作数 = 左操作数 - 右操作数|
| 1 | `*=` | 右 | 赋值，左操作数 = 左操作数 * 右操作数|
| 1 | `/=` | 右 | 赋值，左操作数 = 左操作数 / 右操作数|
| 1 | `%=` | 右 | 赋值，左操作数 = 左操作数 % 右操作数|
| 2 | `||` | 左 | 逻辑"或" |
| 3 | `&&` | 左 | 逻辑"与" |
| 4 | `in` | 左 | 判断 key 在 map 在中；指定元素在 list 中；子符串被包含在字符串中 |
| 5 | `>=` | 左 | 条件"大于等于" |
| 5 | `>`  | 左 | 条件"大于" |
| 5 | `!=` | 左 | 条件"不等于" |
| 5 | `==` | 左 | 条件"等于" |
| 5 | `<=` | 左 | 条件"小于等于" |
| 5 | `<`  | 左 | 条件"小于" |
| 6 | `+`  | 左 | 算术"加" |
| 6 | `-`  | 左 | 算术"减" |
| 7 | `*`  | 左 | 算术"乘" |
| 7 | `/`  | 左 | 算术"除" |
| 7 | `%`  | 左 | 算术"取余数"|
| 8 | `!`  | 右 | 一元运算符；逻辑"取反"，可用于内置的 6 种数据类型 |
| 8 | `+`  | 右 | 一元运算符；正号，可用于表示正数 |
| 8 | `-`  | 右 | 一元运算符；负号，用于翻转符号、表示负数 |
| 9 | `[]` | 左 | 下标运算符；可使用 list 下标或 map 的键取值|
| 9 | `()` | 左 | 可改变运算符优先级；函数调用|

## 表达式 {#expr}

Platypus 使用符号逗号 `,` 作为表达式分隔符号，如用于调用表达式的参数传递和 map、list 的初始化时的表达式的分隔。

在 Platypus 中，表达式可以有值，但**语句一定没有值**，即语句无法作为如 `=` 运算符的左右操作数，而表达式可以。

### 字面量表达式 {#list-expr}

各种数据类型的字面量都可以作为表达式，如整数 `100`, `-1`, `0`, 浮点数 `1.1`，布尔值 `true`, `false` 等。

以下两个为复合类型的字面量表达式写法：

- List 字面量表达式

```txt
[1, true, "1", nil]
```

- Map 字面量表达式

```txt
{
  "a": 1,
  "b": "2",
}
```

### 调用表达式 {#call-expr}

以下为一个函数调用，用于取列表元素个数：

```txt
len([1, 3, "5"])
```

### 二元表达式 {#binary-expr}

二元表达式由二元运算符和左右操作数构成。

当前版本赋值表达式属于二元表达式，其有返回值；但由于赋值表达式可能造成一些问题，后续将会删除该语法，并增加**赋值语句**语法。

```python
# 0
2 / 5

# 0.4，计算时将左操作数的类型提升至浮点数
2 / 5.0

# true
1 + 2 * 3 == 7 && 1 <= 2


# 由于 `=` 运算符的右结合性，a = (b = 3), a == 3
b == 3;
a = b = 3

# 注意：由于赋值表达式语法即将废除，请替换为赋值语句
b = 3
a = b

"a"   in  [1,"a"]   # true
"def" in  "abcdef"  # true
"a"   in  {"a": 1}  # true
"b"   in  {"a": 1}  # false

x = 1; y= [1]
x in y  # true
```

### 索引表达式 {#index-expr}

索引表达式使用 `[]` 下标运算符来对 list/map 的元素进行操作。

可以通过索引表达式对 list 或 map 的元素进行取值或修改以及往 map 中添加元素。
对于列表，可以使用负数进行索引。

语法示例：

```py
a = [1, 2 ,3, -1.]
b = {"a": [-1], "b": 2}

a[-1] = -2
b["a"][-1] = a[-1]

# 结果
# a: [1,2,3,-2]
# b: {"a":[-2],"b":2}
```

### 括号表达式 {#bracket-expr}

括号表达式可以改变二元表达式中的操作数运算优先级，但不能改变结合性：

```txt
# 1 + 2 * 3 == 7

(1 + 2) * 3  # == 9
```

## 语句 {#stmt}

Platypus 所有的表达式可以视为值语句，当表达式以语句分隔符号 `;` 或 `\n` 结束时，其将被视为一个语句，如以下脚本内容包含四个语句：

```go
len("abc")
1
a = 2; a + 2 * 3 % 2
```

### 值语句（表达式语句） {#value-stmt}

表达式后面跟语句分隔符号时可视为值语句，以下为四个合法的语句：

```txt
# 浮点数作为语句
1.;

# 函数调用表达式作为语句
len("Hello World!"); len({"a": 1})

# 标识符作为语句
abc
```

### 赋值语句 {#assignment-stmt}

语法示例：

```py

key_a = "key-a"

# 标识符 a 作为左操作数，赋予 a 一个列表字面量
a = [1, nil, 3]

# 索引表达式作为左操作数
a[0] = 0
a[2] = {"key-b": "value-b"}
a[2][key_a] = 123
```

### 选择语句 {#select-stmt}

Platypus 支持 `if/elif/else` 语法：

```txt
if condition {

}
```

```txt
if condition {

} else {

}
```

```txt
if condition_1 {

} elif condition_2 {

} ... elif condition_n {

} else {

}
```

与大多数编程语言相同，根据 `if/elif` 的条件是否成立，进入对应的语句块中，若都不成立则进入 else 分支。

当前 condition 可以是任意表达式，只要其值为内置数据类型之一，当其值为类型默认值时表达式值为 `flase`：

- 当条件为 `int` 类型值时，其为 `0` 则条件为 `false`，否则为 `true`
- 当条件为 `float` 类型值时，其为 `0.0` 则条件为 `false`，否则为 `true`
- 当条件为 `string` 类型值时，其为空字符串 `""` 则条件为 `false`，否则为 `true`
- 当条件为 `bool` 类型值时，条件为当前值
- 当条件为 `nil` 类型值时，条件为 `false`
- 当条件为 `map` 类型值时，其长度为 0 则条件为 `false`，否则为 `true`
- 当条件为 `list` 类型值时，其长度为 0 则条件为 `false`，否则为 `true`

### 循环语句 {#loop-stmt}

Platypus 支持 `for` 语句和 `for in` 语句。

以下为两个只允许在循环语句块中使用的语句：

- `cotinue` 语句，不再执行后续语句，继续开始下一次循环
- `break` 语句，结束循环

使用 `for` 语句时可能造成无限循环，应谨慎使用，或尽可能使用 `for in` 语句替代。

```txt
for init-expr; condition; loop-expr {

}
```

```txt
for varb_name in map_value/list_value/string_value  {

}
```

使用示例：

- 使用 `for` 执行 10 次循环：

  ```py
  for a = 0; a < 10; a = a + 1 {
    
  }
  ```

- 使用 `for in` 遍历 list 的所有元素：

  ```py
  b = "2"
  for a in ["1", "a" ,"2"] {
    b = b + a
    if b == "21a" {
      break
    }
  }
  # b == "21a"
  ```

- 使用 `for in` 遍历 map 的所有键：

  ```py
  d = 0
  map_a = {"a": 1, "b":2}
  for x in map_a {
    d = d + map_a[x]
  }
  ```

- 使用 `for in` 遍历 string 的所有字符：

  ```py
  s = ""
  for c in "abcdef" {
    if s == "abc" {
      break
    } else {
      continue
    }
    s = s + "a"
  }
  # s == "abc"
  ```
