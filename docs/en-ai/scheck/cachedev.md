# View Memory and Cache Usage in Developer Mode
---

- Version: 1.0.7-7-g251eead
- Release Date: 2023-04-06 11:17:57
- Supported Operating Systems: windows/amd64, windows/386, linux/arm, linux/arm64, linux/386, linux/amd64

## Description
During development testing or actual operation, the size of the cache generated by Lua can sometimes be uncontrollable. For example, caching a list of files in a directory can lead to excessive memory usage when the number of files is too large, which may trigger cgroup limits, causing the process to hang or freeze.

Therefore, using developer mode to monitor memory and cache usage in real-time during operation is necessary.

### cache_dev Developer Mode
### Problems and Solutions:

- Large fluctuations in memory or CPU usage that cannot be pinpointed.
- To address excessive cache usage, it's essential to know how much data is cached.
- During caching, only storage and retrieval (within the same Lua script or scripts with similar functionality) know the type of cache.
- However, within the cache unit, the specific storage type is unknown.
- Sizes for string, bool, int/float types are known, but Lua.table structures cannot directly determine their size.
- Therefore, for Lua.table types, alternative handling is required, such as persisting to disk.
- This ensures that scheck does not consume too much memory during operation; ideally, it should not exceed 150M.
- If scheck abnormally ends the process, it can resume from the previous state.

#### Solutions:

- Scripts of the same type use the same cache with identical keys. Since different files (with different rule IDs) store two identical copies, they should share one cache instead of storing duplicates.
- Solving the above issue brings another challenge: each rule has its own cache key, leading to potential confusion.
- Persist and visualize caches. Benefits include quick problem identification, mock testing, and rule testing.
- Persistence reduces memory overhead accordingly.

## Configuration
Open the configuration file and set pprof to true

```toml
[system]
    ...
 pprof = true
```

After enabling this switch, it listens on `127.0.0.1:6060`, accessible only from the local machine. Use go pprof commands to view memory and CPU usage [Official Documentation](https://code.google.com/p/google-perftools/)

```shell
# Then use the pprof tool to view heap profiles:
go tool pprof http://localhost:6060/debug/pprof/heap
# top 20 
top 20
# list function name or package name 
list

# Or view a 30-second CPU profile
go tool pprof http://localhost:6060/debug/pprof/profile
# Or view goroutine blocking profiles
go tool pprof http://localhost:6060/debug/pprof/block

# To view all available profiles, read http://localhost:6060/debug/pprof/. To learn more about these facilities, visit
http://blog.golang.org/2011/06/profiling-go-programs.html
```

### Caching
After enabling developer mode, Lua script-generated caches are serialized to `cache.json` in the installation directory.
Currently supported Lua types include LTString, LTNumber, LTBool, LTTable.
Unsupported Lua types: LTChannel, LTFunction, LTNil, LTThread, LTUserData.

```
{
	"msg_data": {
		"/boot/grub2/grub.cfg": {           // key
			"c_type": 0,
			"rule_name": "0070-grub-priv", // Rule Name
			"val": "-rw-r--r--"             // val string type
		},
		"/etc/fstab": {
			"c_type": 1,
			"rule_name": "0029-fstab-exist",
			"val": true             // val bool type
		},
		"/usr/lib/systemd/system/docker.socket": {
        	    "c_type": 2,
        	    "rule_name": "0307-docker-socket-priv",
        	    "val": 420          // val number type
        }
    ... 
  }
}
```

The entire cache is written to the file periodically, and scheck does not read the cache content.
Breakpoint restart and other features are under development.