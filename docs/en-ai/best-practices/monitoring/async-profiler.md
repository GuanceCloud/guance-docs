# Utilizing async-profiler for Application Performance Tuning

---

???+ info

    Java profiling, in addition to being obtained through JFR (Java Flight Recording), can also be done using `async-profiler`.

## Introduction to async-profiler

Async-profiler is a low-overhead Java profiler that does not have the <font color="red">Safepoint bias problem</font>. It uses special APIs from HotSpot to collect stack traces and memory allocation information, working on OpenJDK, Oracle JDK, and other JVMs based on HotSpot.

Async-profiler can collect several types of events:

- CPU cycles
- Hardware and software performance counters, such as cache misses, branch misses, page faults, context switches, etc.
- Java heap allocations
- Contended lock attempts, including Java object monitors and ReentrantLocks

**1. CPU Performance Analysis**

In this mode, the profiler collects stack trace samples, which include **Java** methods, **native** calls, **JVM** code, and **kernel** functions.

Typically, it receives call stacks generated by `perf_events` and matches them with call stacks generated by `AsyncGetCallTrace` to create accurate summaries of Java and native code. Additionally, the asynchronous profiler provides a workaround to recover stack traces in cases where `AsyncGetCallTrace` fails.

Compared to Java agents that directly use `perf_events` to translate addresses into Java method names, this method has the following advantages:

- It works with older Java versions because it does not require `-XX:+PreserveFramePointer`, which is only available in JDK 8u60 and later.
- It does not introduce the performance overhead of `-XX:+PreserveFramePointer`, which can be up to 10% in rare cases.
- It does not need to generate mapping files to map Java code addresses to method names.
- It works with interpreted frameworks.
- It does not need to write out perf.data files for further processing in user-space scripts.

**2. Memory Allocation Analysis**

The profiler can be configured to collect call sites that allocate the maximum heap memory instead of detecting CPU-consuming code.

Async-profiler does not use invasive techniques like bytecode instrumentation or expensive `DTrace` probes, which can significantly impact performance. It also does not affect escape analysis or prevent JIT optimizations like allocation elimination. Only actual heap allocations are measured.

The profiler has TLAB-driven sampling capabilities. It relies on HotSpot-specific callbacks to receive two notifications:

- When objects are allocated in newly created TLABs (light blue frames in flame graphs);
- When objects are allocated outside TLABs via the slow path (brown frames).

This means not every allocation is counted but rather one sample per *N* kB of allocations, where *N* is the average size of TLABs. This makes heap sampling very cheap and suitable for production. On the other hand, the collected data may be incomplete, although in practice it usually reflects the highest allocation sources.

The sampling interval can be adjusted using the `--alloc` option. For example, `--alloc 500k` will sample once after an average of 500 KB of allocations. However, intervals smaller than the TLAB size will not work. The minimum supported JDK version is 7u40, where TLAB callbacks first appeared.

**3. Wall-clock Profiling**

The `-e wall` option tells async-profiler to sample all threads at regular intervals regardless of their state: running, sleeping, or blocked. This is useful for analyzing application startup time, for example.

Wall-clock profiling is most useful in per-thread mode: `-t`.

Example: `./profiler.sh -e wall -t -i 5ms -f result.html 8983`

**4. Java Method Performance Analysis**

The `-e ClassName.methodName` option profiles a specific Java method, recording all calls to this method with stack traces.

- Non-native applications, example: `-e java.util.Properties.getProperty` will profile all calls to `getProperty`.
- Native applications, use hardware breakpoints instead, example: `-e Java_java_lang_Throwable_fillInStackTrace`

> **Note:** If you attach async-profiler at runtime, the first instrumentation of non-native Java methods may cause deoptimization of all compiled methods. Subsequent instrumentations only refresh *related code*.

If async-profiler is attached as an agent, no significant CodeCache refresh occurs.

Here are some useful native methods you might want to profile:

- `G1CollectedHeap::humongous_obj_allocate` - tracks G1 GC's _huge allocations_;
- `JVM_StartThread` - tracks new thread creation;
- `Java_java_lang_ClassLoader_defineClass1` - tracks class loading.

## Directory Structure

![image.png](../images/profiling-1.png)

## Launch Methods

Async-profiler is developed as a JVMTI (JVM Tool Interface) Agent and supports two launch methods:

- 1. Loaded with the Java process at startup;
- 2. Dynamically loaded during program execution using the attach API.

### 1 Loading at Startup

???+ warning "Note"

    Loading at startup is suitable only for profiling during application startup, not for real-time analysis during runtime.

If you need to profile some code immediately after JVM starts, instead of using the `profiler.sh` script, you can add `async-profiler` as an agent in the command line. For example:

```
$ java -agentpath:async-profiler-2.8.3/build/libasyncProfiler.so=start,event=alloc,file=profile.html -jar ...
```

![image.png](../images/profiling-2.png)

The agent library is configured via JVMTI parameters, and the format of the parameter string is described in the source code.

- The `profiler.sh` script essentially converts command-line arguments to this format. For example, `-e wall` converts to `event=wall`, and `-f profile.html` converts to `file=profile.html`.
- Some parameters are handled directly by the `profiler.sh` script. For example, `-d 5` includes three actions: attaching the profiler agent with the `start` command, sleeping for 5 seconds, then attaching the agent again with the `stop` command.
![image.png](../images/profiling-3.png)

### 2 Loading During Runtime

More often, you need to profile an application while it is running.

```
./profiler.sh -e alloc -d 10 -f out.html pid
```

![image.png](../images/profiling-4.png)

You can observe the current memory usage, with `reader` allocating 99.77% of the memory. To view supported events:

```
./profiler.sh list jps
```

![image.png](../images/profiling-5.png)

???+ warning "Note"

    HTML format supports single events, while JFR format supports multiple event outputs.

## Integration with Guance

Guance deeply integrates with async-profiler, allowing data to be sent to DataKit and leveraging Guance's powerful UI and analysis capabilities to facilitate multi-dimensional analysis for users.

Refer to the [integration documentation](../../integrations/profile-java.md).

## Case Study

Reading a large file quickly, where the file stores key-value pairs (key:value) and parses them into a map.

### 1 Writing a Large File

```java
import java.io.FileWriter;

public class MapGenerator {
    public static String fileName = "/opt/profiling/map-info.txt";
    public static void main(String[] args) {

        try (FileWriter writer = new FileWriter(fileName)) {
            writer.write("");// Clear original file content
            for (int i = 0; i < 16500000; i++) {
                writer.write("name"+i+":"+i+"\n");
            }
            writer.flush();
            System.out.println("write success!");
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
}
```

### 2 Reading a Large File

=== "Method One: MapReader"

    ```java
    private static Map<String,Long> readMap(String fileName) throws IOException {
        Map<String,Long> map = new HashMap<>();
        try(BufferedReader br = new BufferedReader(new FileReader(fileName))) {
            for (String line ;(line = br.readLine())!=null;){
                String[] kv = line.split(":",2);
                String key = kv[0].trim();
                String value = kv[1].trim();
                map.put(key,Long.parseLong(value));
            }
        }
        return map;
    }
    ```

    Running MapReader takes 15.5 seconds.

    ```shell
    [root@ip-172-31-19-50 profiling]# java MapReader
    Profiling started
    Read 16500000 elements in 15.531 seconds
    ```

    Execute async-profiler simultaneously and push profiling information to the Guance platform for analysis.

    ```shell
    [root@ip-172-31-19-50 async-profiler-2.8.3-linux-x64]# DATAKIT_URL=http://localhost:9529 APP_ENV=test APP_VERSION=1.0.0 HOST_NAME=datakit PROFILING_EVENT=cpu,alloc,lock PROFILING_DURATION=10 PROCESS_ID=`ps -ef |grep java|grep springboot|grep -v grep|awk '{print $2}'` SERVICE_NAME=demo bash collect.sh
    profiling process 16134

    Profiling for 10 seconds
    Done
    generate profiling file successfully for MapReader, pid 16134
      % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
    								 Dload  Upload   Total   Spent    Left  Speed
    100  110k  100    64  100  110k     99   172k --:--:-- --:--:-- --:--:--  172k
    Info: send profile file to datakit successfully
    [root@ip-172-31-19-50 async-profiler-2.8.3-linux-x64]#

    ```

    ![image.png](../images/profiling-6.png)

    ![image.png](../images/profiling-7.png)

    ???+ tip "Result"

        Total memory allocation was 3.79G.

=== "Method Two: MapReader2"

    ```java
    private static Map<String,Long> readMap(String fileName) throws IOException {
        Map<String,Long> map = new HashMap<>();
        try(BufferedReader br = new BufferedReader(new FileReader(fileName))) {
            for (String line ;(line = br.readLine())!=null;){
                int sep = line.indexOf(":");
                String key = trim(line,0,sep);
                String value = trim(line,sep+1,line.length());
                map.put(key,Long.parseLong(value));
            }
        }
        return map;
    }

    private static String trim(String line,int from,int to){
        while (from<to && line.charAt(from) <= ' '){
            from ++;
        }
        while (to > from && line.charAt(to-1) <= ' '){
            to--;
        }
        return line.substring(from,to);
    }
    ```

    Running MapReader2 takes 11.257 seconds.

    ```shell
    [root@ip-172-31-19-50 profiling]# java MapReader2
    Profiling started
    Read 16500000 elements in 11.257 seconds
    [root@ip-172-31-19-50 profiling]#
    ```

    Execute async-profiler simultaneously and push profiling information to the Guance platform for analysis, using the same command as Method One.

    ![image.png](../images/profiling-8.png)

    ???+ tip "Result"

        Total memory allocation was 2.49G, saving 1.3G compared to Method One and reducing processing time by approximately 4 seconds.

=== "Method Three: MapReader3"

    ```java
    private static Map<String,Long> readMap(String fileName) throws IOException {
        Map<String,Long> map = new HashMap<>(600000);
        try(BufferedReader br = new BufferedReader(new FileReader(fileName))) {
            for (String line ;(line = br.readLine())!=null;){
                int sep = line.indexOf(":");
                String key = trim(line,0,sep);
                String value = trim(line,sep+1,line.length());
                map.put(key,Long.parseLong(value));
            }
        }
        return map;
    }

    private static String trim(String line,int from,int to){
        while (from<to && line.charAt(from) <= ' '){
            from ++;
        }
        while (to > from && line.charAt(to-1) <= ' '){
            to--;
        }
        return line.substring(from,to);
    }
    ```

    ![image.png](../images/profiling-9.png)

    ???+ tip "Result"

        Operation steps are the same as Method Two. MapReader3 differs from MapReader2 by initializing the Map with a specified capacity, thus saving 0.3G of memory compared to Method Two and 1.6G compared to Method One.

### 3 Combining Metrics, Traces, and Profiling Analysis

Since the above demo code has a short lifecycle, it cannot provide comprehensive observability (JVM-related metrics, host-related metrics, etc.). Migrating the demo code to a Spring Boot application and using APM (ddtrace-agent) along with JVM metrics and async-profiler allows observability from three dimensions: **metrics (JVM/host), traces (current chain situation), and profiling (performance analysis)**. By accessing corresponding URLs, perform async-profiler analysis.

- Profiling View

![image.png](../images/profiling-10.png)

- JVM View

![image.png](../images/profiling-11.png)

- Trace View

![image.png](../images/profiling-12.png)

### 4 Summary

![image.png](../images/profiling-13.png)

## About TLAB

TLAB stands for Thread Local Allocation Buffer, a concept in Java memory allocation. It is a thread-dedicated memory allocation area used when creating objects to reduce contention in multi-threaded environments. Objects are allocated within this buffer without requiring locking operations.

???+ note

    For most JVM applications, most objects are allocated in TLABs. If too many allocations occur outside TLABs or if TLAB re-allocation is frequent, check your code for large objects or irregularly sized allocations to optimize performance.

### Allocations in New TLAB Size

Mainly collects `jdk.ObjectAllocationInNewTLAB` events, referred to as "slow TLAB allocations."

### Allocations Outside TLAB Size

Mainly collects `jdk.ObjectAllocationOutsideTLAB` events, referred to as "allocations outside TLAB."

## Profiling Tool Comparison

![image.png](../images/profiling-14.png)

## References

<[async-profiler](https://github.com/jvm-profiling-tools/async-profiler)>

<[DataKit Integration with async-profiler](/integrations/profile-java#install)>

<[async-profiler Demo Code](https://github.com/lrwh/observable-demo/tree/main/profiling)>

<[async-profiler Spring Boot Demo Code](https://github.com/lrwh/observable-demo/blob/main/springboot-ddtrace-server/async-profiler.md)>